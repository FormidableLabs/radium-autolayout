(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("react"));
	else if(typeof define === 'function' && define.amd)
		define(["react"], factory);
	else if(typeof exports === 'object')
		exports["RadiumConstraints"] = factory(require("react"));
	else
		root["RadiumConstraints"] = factory(root["React"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_2__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.constrain = exports.AutoSVG = exports.AutoDOM = exports.Subview = exports.View = undefined;
	
	var _constraintLayout = __webpack_require__(1);
	
	var _constraintLayout2 = _interopRequireDefault(_constraintLayout);
	
	var _view = __webpack_require__(5);
	
	var _view2 = _interopRequireDefault(_view);
	
	var _subview = __webpack_require__(7);
	
	var _subview2 = _interopRequireDefault(_subview);
	
	var _autodom = __webpack_require__(8);
	
	var _autodom2 = _interopRequireDefault(_autodom);
	
	var _autosvg = __webpack_require__(9);
	
	var _autosvg2 = _interopRequireDefault(_autosvg);
	
	var _constraintBuilder = __webpack_require__(10);
	
	var _constraintBuilder2 = _interopRequireDefault(_constraintBuilder);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = _constraintLayout2.default;
	exports.View = _view2.default;
	exports.Subview = _subview2.default;
	exports.AutoDOM = _autodom2.default;
	exports.AutoSVG = _autosvg2.default;
	exports.constrain = _constraintBuilder2.default;

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _layoutClient = __webpack_require__(3);
	
	var _layoutClient2 = _interopRequireDefault(_layoutClient);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var ConstraintLayout = function (_Component) {
	  _inherits(ConstraintLayout, _Component);
	
	  function ConstraintLayout(props) {
	    _classCallCheck(this, ConstraintLayout);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ConstraintLayout).call(this, props));
	
	    _this.client = new _layoutClient2.default();
	    return _this;
	  }
	
	  _createClass(ConstraintLayout, [{
	    key: "componentWillUnmount",
	    value: function componentWillUnmount() {
	      this.client.terminate();
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      return _react2.default.createElement(
	        "div",
	        null,
	        this.props.children
	      );
	    }
	  }, {
	    key: "getChildContext",
	    value: function getChildContext() {
	      return {
	        client: this.client
	      };
	    }
	  }]);
	
	  return ConstraintLayout;
	}(_react.Component);
	
	ConstraintLayout.childContextTypes = {
	  client: _react.PropTypes.instanceOf(_layoutClient2.default)
	};
	ConstraintLayout.propTypes = {
	  children: _react.PropTypes.node
	};
	exports.default = ConstraintLayout;

/***/ },
/* 2 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_2__;

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	/* eslint-env browser */
	
	var _workerProxy = __webpack_require__(4);
	
	var _workerProxy2 = _interopRequireDefault(_workerProxy);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var LayoutWorker = function LayoutWorker() {
	  return new Worker(URL.createObjectURL(new Blob([atob("IWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoaSl7aWYocltpXSlyZXR1cm4gcltpXS5leHBvcnRzO3ZhciBuPXJbaV09e2V4cG9ydHM6e30saWQ6aSxsb2FkZWQ6ITF9O3JldHVybiB0W2ldLmNhbGwobi5leHBvcnRzLG4sbi5leHBvcnRzLGUpLG4ubG9hZGVkPSEwLG4uZXhwb3J0c312YXIgcj17fTtyZXR1cm4gZS5tPXQsZS5jPXIsZS5wPSIiLGUoMCl9KFtmdW5jdGlvbih0LGUscil7InVzZSBzdHJpY3QiO2Z1bmN0aW9uIGkodCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OnsiZGVmYXVsdCI6dH19ZnVuY3Rpb24gbih0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbiIpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt2YXIgYT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIHI9MDtyPGUubGVuZ3RoO3IrKyl7dmFyIGk9ZVtyXTtpLmVudW1lcmFibGU9aS5lbnVtZXJhYmxlfHwhMSxpLmNvbmZpZ3VyYWJsZT0hMCwidmFsdWUiaW4gaSYmKGkud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGkua2V5LGkpfX1yZXR1cm4gZnVuY3Rpb24oZSxyLGkpe3JldHVybiByJiZ0KGUucHJvdG90eXBlLHIpLGkmJnQoZSxpKSxlfX0oKSxzPXIoMSksbz1pKHMpLHU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZnVuY3Rpb24ocil7dmFyIGk9ZShyKTtwb3N0TWVzc2FnZSh7bWV0aG9kOnQscmVzdWx0Oml9KX19LGM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7bih0aGlzLHQpLHRoaXMudmlld3M9e319cmV0dXJuIGEodCxbe2tleToicmVnaXN0ZXJWaWV3Iix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10LnZpZXdOYW1lLHI9bmV3IG9bImRlZmF1bHQiXTt0aGlzLnZpZXdzW2VdPXI7dmFyIGk9dC5zaXplfHxudWxsO3JldHVybiBpJiZyLnNldFNpemUoaS53aWR0aCxpLmhlaWdodCksdC5zcGFjaW5nJiZyLnNldFNwYWNpbmcodC5zcGFjaW5nKSwhMH19LHtrZXk6ImRlcmVnaXN0ZXJWaWV3Iix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10LnZpZXdOYW1lO3JldHVybiB0aGlzLnZpZXdzW2VdPW51bGwsITB9fSx7a2V5OiJzZXRTcGFjaW5nIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10LnZpZXdOYW1lLHI9dGhpcy52aWV3c1tlXTtpZighcilyZXR1cm4gbnVsbDt2YXIgaT10LnNwYWNpbmd8fG51bGw7cmV0dXJuIGk/KHIuc2V0U3BhY2luZyhpKSx0aGlzLnN1YnZpZXdzKHt2aWV3TmFtZTplfSkpOm51bGx9fSx7a2V5OiJzZXRTaXplIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10LnZpZXdOYW1lLHI9dGhpcy52aWV3c1tlXSxpPXQuc2l6ZTtyZXR1cm4gciYmaT8oci5zZXRTaXplKGkud2lkdGgsaS5oZWlnaHQpLHRoaXMuc3Vidmlld3Moe3ZpZXdOYW1lOmV9KSk6bnVsbH19LHtrZXk6ImFkZEludHJpbnNpY3MiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXQudmlld05hbWUscj10LnN1YnZpZXdOYW1lfHxudWxsO2lmKCFyKXJldHVybiBudWxsO3ZhciBpPXRoaXMudmlld3NbZV18fG51bGw7aWYoIWkpcmV0dXJuIG51bGw7dmFyIG49dGhpcy5nZXRTdWJ2aWV3KGksciksYT10LmludHJpbnNpY3N8fG51bGw7cmV0dXJuIG4mJmE/KG4uaW50cmluc2ljV2lkdGg9YS5pbnRyaW5zaWNXaWR0aHx8bi5pbnRyaW5zaWNXaWR0aCxuLmludHJpbnNpY0hlaWdodD1hLmludHJpbnNpY0hlaWdodHx8bi5pbnRyaW5zaWNIZWlnaHQsdGhpcy5zdWJ2aWV3cyh7dmlld05hbWU6ZX0pKTpudWxsfX0se2tleToiYWRkQ29uc3RyYWludHMiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXQudmlld05hbWUscj10aGlzLnZpZXdzW2VdO2lmKCFyKXJldHVybiBudWxsO3ZhciBpPXQuY29uc3RyYWludHN8fG51bGw7cmV0dXJuIGk/KHIuYWRkQ29uc3RyYWludHMoaSksdGhpcy5zdWJ2aWV3cyh7dmlld05hbWU6ZX0pKTpudWxsfX0se2tleToiaW5pdGlhbGl6ZVN1YnZpZXdzIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLHI9dC52aWV3TmFtZSxpPXQubGF5b3V0UHJvcHN8fG51bGw7aWYoIWkpcmV0dXJuIG51bGw7dmFyIG49aS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQuY29uc3RyYWludHN9KS5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuIHR9KS5yZWR1Y2UoZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5jb25jYXQoZSl9LFtdKTtyZXR1cm4gdGhpcy5hZGRDb25zdHJhaW50cyh7dmlld05hbWU6cixjb25zdHJhaW50czpufSksaS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3ZhciBpPXQubmFtZSxuPXQuaW50cmluc2ljV2lkdGgsYT10LmludHJpbnNpY0hlaWdodDtlLmFkZEludHJpbnNpY3Moe3ZpZXdOYW1lOnIsc3Vidmlld05hbWU6aSxpbnRyaW5zaWNzOntpbnRyaW5zaWNXaWR0aDpuLGludHJpbnNpY0hlaWdodDphfX0pfSksdGhpcy5zdWJ2aWV3cyh7dmlld05hbWU6cn0pfX0se2tleToic3Vidmlld3MiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMudmlld3NbdC52aWV3TmFtZV07cmV0dXJuIGUmJmUuc3ViVmlld3M/T2JqZWN0LmtleXMoZS5zdWJWaWV3cykucmVkdWNlKGZ1bmN0aW9uKHQscil7dmFyIGk9ZS5zdWJWaWV3c1tyXSxuPXt3aWR0aDppLndpZHRoLGhlaWdodDppLmhlaWdodCxsZWZ0OmkubGVmdCx0b3A6aS50b3AscmlnaHQ6aS5yaWdodCxib3R0b206aS5ib3R0b219O3JldHVybiB0W3JdPXtsYXlvdXQ6bn0sdH0se30pOm51bGx9fSx7a2V5OiJnZXRTdWJ2aWV3Iix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciByPXQuc3ViVmlld3N8fG51bGw7aWYoIXIpcmV0dXJuIG51bGw7dmFyIGk9cltlXTtyZXR1cm4gaXx8bnVsbH19XSksdH0oKTtlWyJkZWZhdWx0Il09Yzt2YXIgZj1uZXcgYztvbm1lc3NhZ2U9ZnVuY3Rpb24odCl7dmFyIGU9dC5kYXRhLHI9ZS5tZXRob2QsaT1lLmFyZ3M7ZltyXSYmdShyLGZbcl0uYmluZChmKSkoaSl9fSxmdW5jdGlvbih0LGUscil7InVzZSBzdHJpY3QiO2Z1bmN0aW9uIGkodCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OnsiZGVmYXVsdCI6dH19ZnVuY3Rpb24gbih0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbiIpfWZ1bmN0aW9uIGEodCxlKXt2YXIgcj1uZXcgbFsiZGVmYXVsdCJdLlZhcmlhYmxlO3JldHVybiB0aGlzLl9zb2x2ZXIuYWRkQ29uc3RyYWludChuZXcgbFsiZGVmYXVsdCJdLkNvbnN0cmFpbnQocixsWyJkZWZhdWx0Il0uT3BlcmF0b3IuRXEsZSkpLHJ9ZnVuY3Rpb24gcyh0KXtyZXR1cm4gdD90Lm5hbWU/KHRoaXMuX3N1YlZpZXdzW3QubmFtZV09dGhpcy5fc3ViVmlld3NbdC5uYW1lXXx8bmV3IG1bImRlZmF1bHQiXSh7bmFtZTp0Lm5hbWUsc29sdmVyOnRoaXMuX3NvbHZlcn0pLHRoaXMuX3N1YlZpZXdzW3QubmFtZV0uX3R5cGU9dGhpcy5fc3ViVmlld3NbdC5uYW1lXS5fdHlwZXx8dC50eXBlLHRoaXMuX3N1YlZpZXdzW3QubmFtZV0pOih0aGlzLl9zdWJWaWV3c1t0XT10aGlzLl9zdWJWaWV3c1t0XXx8bmV3IG1bImRlZmF1bHQiXSh7bmFtZTp0LHNvbHZlcjp0aGlzLl9zb2x2ZXJ9KSx0aGlzLl9zdWJWaWV3c1t0XSk6dGhpcy5fcGFyZW50U3ViVmlld31mdW5jdGlvbiBvKHQpe3ZhciBlPTQ7aWYodC52aWV3MXx8ImxlZnQiIT09dC5hdHRyMSlpZih0LnZpZXcxfHwidG9wIiE9PXQuYXR0cjEpaWYodC52aWV3Mnx8InJpZ2h0IiE9PXQuYXR0cjIpaWYodC52aWV3Mnx8ImJvdHRvbSIhPT10LmF0dHIyKXN3aXRjaCh0LmF0dHIxKXtjYXNlImxlZnQiOmNhc2UicmlnaHQiOmNhc2UiY2VudGVyWCI6Y2FzZSJsZWFkaW5nIjpjYXNlInRyYWlsaW5nIjplPTQ7YnJlYWs7Y2FzZSJ6SW5kZXgiOmU9NjticmVhaztkZWZhdWx0OmU9NX1lbHNlIGU9MjtlbHNlIGU9MTtlbHNlIGU9MDtlbHNlIGU9MztyZXR1cm4gdGhpcy5fc3BhY2luZ1ZhcnM9dGhpcy5fc3BhY2luZ1ZhcnN8fG5ldyBBcnJheSg3KSx0aGlzLl9zcGFjaW5nRXhwcj10aGlzLl9zcGFjaW5nRXhwcnx8bmV3IEFycmF5KDcpLHRoaXMuX3NwYWNpbmdWYXJzW2VdfHwodGhpcy5fc3BhY2luZ1ZhcnNbZV09bmV3IGxbImRlZmF1bHQiXS5WYXJpYWJsZSx0aGlzLl9zb2x2ZXIuYWRkRWRpdFZhcmlhYmxlKHRoaXMuX3NwYWNpbmdWYXJzW2VdLGxbImRlZmF1bHQiXS5TdHJlbmd0aC5jcmVhdGUoOTk5LDFlMywxZTMpKSx0aGlzLl9zcGFjaW5nRXhwcltlXT10aGlzLl9zcGFjaW5nVmFyc1tlXS5tdWx0aXBseSgtMSksdGhpcy5fc29sdmVyLnN1Z2dlc3RWYWx1ZSh0aGlzLl9zcGFjaW5nVmFyc1tlXSx0aGlzLl9zcGFjaW5nW2VdKSksdGhpcy5fc3BhY2luZ0V4cHJbZV19ZnVuY3Rpb24gdSh0KXt2YXIgZT12b2lkIDAscj12b2lkIDAhPT10Lm11bHRpcGxpZXI/dC5tdWx0aXBsaWVyOjEsaT12b2lkIDAhPT10LmNvbnN0YW50P3QuY29uc3RhbnQ6MDsiZGVmYXVsdCI9PT1pJiYoaT1vLmNhbGwodGhpcyx0KSk7dmFyIG49cy5jYWxsKHRoaXMsdC52aWV3MSkuX2dldEF0dHIodC5hdHRyMSksdT12b2lkIDA7dC5hdHRyMj09PWRbImRlZmF1bHQiXS5DT05TVD91PWEuY2FsbCh0aGlzLHZvaWQgMCx0LmNvbnN0YW50KToodT1zLmNhbGwodGhpcyx0LnZpZXcyKS5fZ2V0QXR0cih0LmF0dHIyKSwxIT09ciYmaT91PXUubXVsdGlwbHkocikucGx1cyhpKTppP3U9dS5wbHVzKGkpOjEhPT1yJiYodT11Lm11bHRpcGx5KHIpKSk7dmFyIGM9dm9pZCAwIT09dC5wcmlvcml0eSYmdC5wcmlvcml0eTwxZTM/bFsiZGVmYXVsdCJdLlN0cmVuZ3RoLmNyZWF0ZSgwLHQucHJpb3JpdHksMWUzKTp3O3N3aXRjaCh0LnJlbGF0aW9uKXtjYXNlIHZbImRlZmF1bHQiXS5FUVU6ZT1uZXcgbFsiZGVmYXVsdCJdLkNvbnN0cmFpbnQobixsWyJkZWZhdWx0Il0uT3BlcmF0b3IuRXEsdSxjKTticmVhaztjYXNlIHZbImRlZmF1bHQiXS5HRVE6ZT1uZXcgbFsiZGVmYXVsdCJdLkNvbnN0cmFpbnQobixsWyJkZWZhdWx0Il0uT3BlcmF0b3IuR2UsdSxjKTticmVhaztjYXNlIHZbImRlZmF1bHQiXS5MRVE6ZT1uZXcgbFsiZGVmYXVsdCJdLkNvbnN0cmFpbnQobixsWyJkZWZhdWx0Il0uT3BlcmF0b3IuTGUsdSxjKTticmVhaztkZWZhdWx0OnRocm93IkludmFsaWQgcmVsYXRpb24gc3BlY2lmaWVkOiAiK3QucmVsYXRpb259dGhpcy5fc29sdmVyLmFkZENvbnN0cmFpbnQoZSl9ZnVuY3Rpb24gYyh0LGUpe2lmKHQ9PT1lKXJldHVybiEwO2lmKCF0fHwhZSlyZXR1cm4hMTtmb3IodmFyIHI9MDs3PnI7cisrKWlmKHRbcl0hPT1lW3JdKXJldHVybiExO3JldHVybiEwfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt2YXIgZj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIHI9MDtyPGUubGVuZ3RoO3IrKyl7dmFyIGk9ZVtyXTtpLmVudW1lcmFibGU9aS5lbnVtZXJhYmxlfHwhMSxpLmNvbmZpZ3VyYWJsZT0hMCwidmFsdWUiaW4gaSYmKGkud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGkua2V5LGkpfX1yZXR1cm4gZnVuY3Rpb24oZSxyLGkpe3JldHVybiByJiZ0KGUucHJvdG90eXBlLHIpLGkmJnQoZSxpKSxlfX0oKSxoPXIoMiksbD1pKGgpLHA9cigzKSxkPWkocCksXz1yKDQpLHY9aShfKSx5PXIoNSksbT1pKHkpLHc9bFsiZGVmYXVsdCJdLlN0cmVuZ3RoLmNyZWF0ZSgwLDFlMywxZTMpLGc9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGUpe24odGhpcyx0KSx0aGlzLl9zb2x2ZXI9bmV3IGxbImRlZmF1bHQiXS5Tb2x2ZXIsdGhpcy5fc3ViVmlld3M9e30sdGhpcy5fcGFyZW50U3ViVmlldz1uZXcgbVsiZGVmYXVsdCJdKHtzb2x2ZXI6dGhpcy5fc29sdmVyfSksdGhpcy5zZXRTcGFjaW5nKGUmJnZvaWQgMCE9PWUuc3BhY2luZz9lLnNwYWNpbmc6OCksZSYmKHZvaWQgMD09PWUud2lkdGgmJnZvaWQgMD09PWUuaGVpZ2h0fHx0aGlzLnNldFNpemUoZS53aWR0aCxlLmhlaWdodCksZS5jb25zdHJhaW50cyYmdGhpcy5hZGRDb25zdHJhaW50cyhlLmNvbnN0cmFpbnRzKSl9cmV0dXJuIGYodCxbe2tleToic2V0U2l6ZSIsdmFsdWU6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5fcGFyZW50U3ViVmlldy5pbnRyaW5zaWNXaWR0aD10LHRoaXMuX3BhcmVudFN1YlZpZXcuaW50cmluc2ljSGVpZ2h0PWUsdGhpc319LHtrZXk6InNldFNwYWNpbmciLHZhbHVlOmZ1bmN0aW9uKHQpe3N3aXRjaChBcnJheS5pc0FycmF5KHQpP3QubGVuZ3RoOi0xKXtjYXNlLTE6dD1bdCx0LHQsdCx0LHQsMV07YnJlYWs7Y2FzZSAxOnQ9W3RbMF0sdFswXSx0WzBdLHRbMF0sdFswXSx0WzBdLDFdO2JyZWFrO2Nhc2UgMjp0PVt0WzFdLHRbMF0sdFsxXSx0WzBdLHRbMF0sdFsxXSwxXTticmVhaztjYXNlIDM6dD1bdFsxXSx0WzBdLHRbMV0sdFswXSx0WzBdLHRbMV0sdFsyXV07YnJlYWs7Y2FzZSA2OnQ9W3RbMF0sdFsxXSx0WzJdLHRbM10sdFs0XSx0WzVdLDFdO2JyZWFrO2Nhc2UgNzpicmVhaztkZWZhdWx0OnRocm93IkludmFsaWQgc3BhY2luZyBzeW50YXgifWlmKCFjKHRoaXMuX3NwYWNpbmcsdCkmJih0aGlzLl9zcGFjaW5nPXQsdGhpcy5fc3BhY2luZ1ZhcnMpKXtmb3IodmFyIGU9MDtlPHRoaXMuX3NwYWNpbmdWYXJzLmxlbmd0aDtlKyspdGhpcy5fc3BhY2luZ1ZhcnNbZV0mJnRoaXMuX3NvbHZlci5zdWdnZXN0VmFsdWUodGhpcy5fc3BhY2luZ1ZhcnNbZV0sdGhpcy5fc3BhY2luZ1tlXSk7dGhpcy5fc29sdmVyLnVwZGF0ZVZhcmlhYmxlcygpfXJldHVybiB0aGlzfX0se2tleToiYWRkQ29uc3RyYWludCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIHUuY2FsbCh0aGlzLHQpLHRoaXMuX3NvbHZlci51cGRhdGVWYXJpYWJsZXMoKSx0aGlzfX0se2tleToiYWRkQ29uc3RyYWludHMiLHZhbHVlOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wO2U8dC5sZW5ndGg7ZSsrKXUuY2FsbCh0aGlzLHRbZV0pO3JldHVybiB0aGlzLl9zb2x2ZXIudXBkYXRlVmFyaWFibGVzKCksdGhpc319LHtrZXk6IndpZHRoIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcGFyZW50U3ViVmlldy5pbnRyaW5zaWNXaWR0aH19LHtrZXk6ImhlaWdodCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3BhcmVudFN1YlZpZXcuaW50cmluc2ljSGVpZ2h0fX0se2tleToiZml0dGluZ1dpZHRoIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcGFyZW50U3ViVmlldy53aWR0aH19LHtrZXk6ImZpdHRpbmdIZWlnaHQiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9wYXJlbnRTdWJWaWV3LmhlaWdodH19LHtrZXk6InN1YlZpZXdzIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc3ViVmlld3N9fV0pLHR9KCk7ZVsiZGVmYXVsdCJdPWd9LGZ1bmN0aW9uKHQsZSxyKXt2YXIgaSxuOyFmdW5jdGlvbihyLGEpe2k9W10sbj1mdW5jdGlvbigpe3JldHVybiByLmtpd2k9YSgpfS5hcHBseShlLGkpLCEodm9pZCAwIT09biYmKHQuZXhwb3J0cz1uKSl9KHRoaXMsZnVuY3Rpb24oKXt2YXIgdDshZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSh0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIEFycmF5P25ldyBhKHQpOnQuX19pdGVyX18oKX1mdW5jdGlvbiByKHQpe3JldHVybiB0IGluc3RhbmNlb2YgQXJyYXk/bmV3IHModCk6dC5fX3JldmVyc2VkX18oKX1mdW5jdGlvbiBpKHQpe3JldHVybiB0Ll9fbmV4dF9fKCl9ZnVuY3Rpb24gbih0LGUpe2lmKHQgaW5zdGFuY2VvZiBBcnJheSl7Zm9yKHZhciByPTAsaT10Lmxlbmd0aDtpPnI7KytyKWlmKGUodFtyXSk9PT0hMSlyZXR1cm59ZWxzZSBmb3IodmFyIG4sYT10Ll9faXRlcl9fKCk7dm9pZCAwIT09KG49YS5fX25leHRfXygpKTspaWYoZShuKT09PSExKXJldHVybn12YXIgYT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXsidW5kZWZpbmVkIj09dHlwZW9mIGUmJihlPTApLHRoaXMuX2FycmF5PXQsdGhpcy5faW5kZXg9TWF0aC5tYXgoMCxNYXRoLm1pbihlLHQubGVuZ3RoKSl9cmV0dXJuIHQucHJvdG90eXBlLl9fbmV4dF9fPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2FycmF5W3RoaXMuX2luZGV4KytdfSx0LnByb3RvdHlwZS5fX2l0ZXJfXz1mdW5jdGlvbigpe3JldHVybiB0aGlzfSx0fSgpO3QuQXJyYXlJdGVyYXRvcj1hO3ZhciBzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpeyJ1bmRlZmluZWQiPT10eXBlb2YgZSYmKGU9dC5sZW5ndGgpLHRoaXMuX2FycmF5PXQsdGhpcy5faW5kZXg9TWF0aC5tYXgoMCxNYXRoLm1pbihlLHQubGVuZ3RoKSl9cmV0dXJuIHQucHJvdG90eXBlLl9fbmV4dF9fPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2FycmF5Wy0tdGhpcy5faW5kZXhdfSx0LnByb3RvdHlwZS5fX2l0ZXJfXz1mdW5jdGlvbigpe3JldHVybiB0aGlzfSx0fSgpO3QuUmV2ZXJzZUFycmF5SXRlcmF0b3I9cyx0Lml0ZXI9ZSx0LnJldmVyc2VkPXIsdC5uZXh0PWksdC5mb3JFYWNoPW59KHR8fCh0PXt9KSk7dmFyIHQ7IWZ1bmN0aW9uKHQpe3ZhciBlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe3RoaXMuZmlyc3Q9dCx0aGlzLnNlY29uZD1lfXJldHVybiB0LnByb3RvdHlwZS5jb3B5PWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyB0KHRoaXMuZmlyc3QsdGhpcy5zZWNvbmQpfSx0fSgpO3QuUGFpcj1lfSh0fHwodD17fSkpO3ZhciB0OyFmdW5jdGlvbih0KXtmdW5jdGlvbiBlKHQsZSxyKXtmb3IodmFyIGksbixhPTAscz10Lmxlbmd0aDtzPjA7KWk9cz4+MSxuPWEraSxyKHRbbl0sZSk8MD8oYT1uKzEscy09aSsxKTpzPWk7cmV0dXJuIGF9ZnVuY3Rpb24gcih0LHIsaSl7dmFyIG49ZSh0LHIsaSk7aWYobj09PXQubGVuZ3RoKXJldHVybi0xO3ZhciBhPXRbbl07cmV0dXJuIDAhPT1pKGEscik/LTE6bn1mdW5jdGlvbiBpKHQscixpKXt2YXIgbj1lKHQscixpKTtpZihuIT09dC5sZW5ndGgpe3ZhciBhPXRbbl07aWYoMD09PWkoYSxyKSlyZXR1cm4gYX19dC5sb3dlckJvdW5kPWUsdC5iaW5hcnlTZWFyY2g9cix0LmJpbmFyeUZpbmQ9aX0odHx8KHQ9e30pKTt2YXIgdDshZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7dGhpcy5fYXJyYXk9W119cmV0dXJuIGUucHJvdG90eXBlLnNpemU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYXJyYXkubGVuZ3RofSxlLnByb3RvdHlwZS5lbXB0eT1mdW5jdGlvbigpe3JldHVybiAwPT09dGhpcy5fYXJyYXkubGVuZ3RofSxlLnByb3RvdHlwZS5pdGVtQXQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX2FycmF5W3RdfSxlLnByb3RvdHlwZS50YWtlQXQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX2FycmF5LnNwbGljZSh0LDEpWzBdfSxlLnByb3RvdHlwZS5jbGVhcj1mdW5jdGlvbigpe3RoaXMuX2FycmF5PVtdfSxlLnByb3RvdHlwZS5zd2FwPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuX2FycmF5O3RoaXMuX2FycmF5PXQuX2FycmF5LHQuX2FycmF5PWV9LGUucHJvdG90eXBlLl9faXRlcl9fPWZ1bmN0aW9uKCl7cmV0dXJuIHQuaXRlcih0aGlzLl9hcnJheSl9LGUucHJvdG90eXBlLl9fcmV2ZXJzZWRfXz1mdW5jdGlvbigpe3JldHVybiB0LnJldmVyc2VkKHRoaXMuX2FycmF5KX0sZX0oKTt0LkFycmF5QmFzZT1lfSh0fHwodD17fSkpO3ZhciB0LGU9dGhpcy5fX2V4dGVuZHN8fGZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gcigpe3RoaXMuY29uc3RydWN0b3I9dH1mb3IodmFyIGkgaW4gZSllLmhhc093blByb3BlcnR5KGkpJiYodFtpXT1lW2ldKTtyLnByb3RvdHlwZT1lLnByb3RvdHlwZSx0LnByb3RvdHlwZT1uZXcgcn07IWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIHIodCl7cmV0dXJuIGZ1bmN0aW9uKGUscil7cmV0dXJuIHQoZS5maXJzdCxyKX19ZnVuY3Rpb24gaSh0LGUscil7Zm9yKHZhciBpPTAsbj0wLGE9dC5sZW5ndGgscz1lLmxlbmd0aCxvPVtdO2E+aSYmcz5uOyl7dmFyIHU9dFtpXSxjPWVbbl0sZj1yKHUuZmlyc3QsYy5maXJzdCk7MD5mPyhvLnB1c2godS5jb3B5KCkpLCsraSk6Zj4wPyhvLnB1c2goYy5jb3B5KCkpLCsrbik6KG8ucHVzaChjLmNvcHkoKSksKytpLCsrbil9Zm9yKDthPmk7KW8ucHVzaCh0W2ldLmNvcHkoKSksKytpO2Zvcig7cz5uOylvLnB1c2goZVtuXS5jb3B5KCkpLCsrbjtyZXR1cm4gb312YXIgbj1mdW5jdGlvbihuKXtmdW5jdGlvbiBhKHQpe24uY2FsbCh0aGlzKSx0aGlzLl9jb21wYXJlPXQsdGhpcy5fd3JhcHBlZD1yKHQpfXJldHVybiBlKGEsbiksYS5wcm90b3R5cGUuY29tcGFyaXRvcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9jb21wYXJlfSxhLnByb3RvdHlwZS5pbmRleE9mPWZ1bmN0aW9uKGUpe3JldHVybiB0LmJpbmFyeVNlYXJjaCh0aGlzLl9hcnJheSxlLHRoaXMuX3dyYXBwZWQpfSxhLnByb3RvdHlwZS5jb250YWlucz1mdW5jdGlvbihlKXtyZXR1cm4gdC5iaW5hcnlTZWFyY2godGhpcy5fYXJyYXksZSx0aGlzLl93cmFwcGVkKT49MH0sYS5wcm90b3R5cGUuZmluZD1mdW5jdGlvbihlKXtyZXR1cm4gdC5iaW5hcnlGaW5kKHRoaXMuX2FycmF5LGUsdGhpcy5fd3JhcHBlZCl9LGEucHJvdG90eXBlLnNldERlZmF1bHQ9ZnVuY3Rpb24oZSxyKXt2YXIgaT10aGlzLl9hcnJheSxuPXQubG93ZXJCb3VuZChpLGUsdGhpcy5fd3JhcHBlZCk7aWYobj09PWkubGVuZ3RoKXt2YXIgYT1uZXcgdC5QYWlyKGUscigpKTtyZXR1cm4gaS5wdXNoKGEpLGF9dmFyIHM9aVtuXTtpZigwIT09dGhpcy5fY29tcGFyZShzLmZpcnN0LGUpKXt2YXIgYT1uZXcgdC5QYWlyKGUscigpKTtyZXR1cm4gaS5zcGxpY2UobiwwLGEpLGF9cmV0dXJuIHN9LGEucHJvdG90eXBlLmluc2VydD1mdW5jdGlvbihlLHIpe3ZhciBpPXRoaXMuX2FycmF5LG49dC5sb3dlckJvdW5kKGksZSx0aGlzLl93cmFwcGVkKTtpZihuPT09aS5sZW5ndGgpe3ZhciBhPW5ldyB0LlBhaXIoZSxyKTtyZXR1cm4gaS5wdXNoKGEpLGF9dmFyIHM9aVtuXTtpZigwIT09dGhpcy5fY29tcGFyZShzLmZpcnN0LGUpKXt2YXIgYT1uZXcgdC5QYWlyKGUscik7cmV0dXJuIGkuc3BsaWNlKG4sMCxhKSxhfXJldHVybiBzLnNlY29uZD1yLHN9LGEucHJvdG90eXBlLnVwZGF0ZT1mdW5jdGlvbihlKXt2YXIgcj10aGlzO2lmKGUgaW5zdGFuY2VvZiBhKXt2YXIgbj1lO3RoaXMuX2FycmF5PWkodGhpcy5fYXJyYXksbi5fYXJyYXksdGhpcy5fY29tcGFyZSl9ZWxzZSB0LmZvckVhY2goZSxmdW5jdGlvbih0KXtyLmluc2VydCh0LmZpcnN0LHQuc2Vjb25kKX0pfSxhLnByb3RvdHlwZS5lcmFzZT1mdW5jdGlvbihlKXt2YXIgcj10aGlzLl9hcnJheSxpPXQuYmluYXJ5U2VhcmNoKHIsZSx0aGlzLl93cmFwcGVkKTtyZXR1cm4gMD5pP3ZvaWQgMDpyLnNwbGljZShpLDEpWzBdfSxhLnByb3RvdHlwZS5jb3B5PWZ1bmN0aW9uKCl7Zm9yKHZhciB0PW5ldyBhKHRoaXMuX2NvbXBhcmUpLGU9dC5fYXJyYXkscj10aGlzLl9hcnJheSxpPTAsbj1yLmxlbmd0aDtuPmk7KytpKWUucHVzaChyW2ldLmNvcHkoKSk7cmV0dXJuIHR9LGF9KHQuQXJyYXlCYXNlKTt0LkFzc29jaWF0aXZlQXJyYXk9bn0odHx8KHQ9e30pKTt2YXIgcjshZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQpe3RbdC5MZT0wXT0iTGUiLHRbdC5HZT0xXT0iR2UiLHRbdC5FcT0yXT0iRXEifSh0Lk9wZXJhdG9yfHwodC5PcGVyYXRvcj17fSkpO3ZhciBlPSh0Lk9wZXJhdG9yLGZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLGksbixhKXt2b2lkIDA9PT1hJiYoYT10LlN0cmVuZ3RoLnJlcXVpcmVkKSx0aGlzLl9pZD1yKyssdGhpcy5fb3BlcmF0b3I9aSx0aGlzLl9zdHJlbmd0aD10LlN0cmVuZ3RoLmNsaXAoYSksdm9pZCAwPT09biYmZSBpbnN0YW5jZW9mIHQuRXhwcmVzc2lvbj90aGlzLl9leHByZXNzaW9uPWU6dGhpcy5fZXhwcmVzc2lvbj1lLm1pbnVzKG4pfXJldHVybiBlLkNvbXBhcmU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5pZCgpLWUuaWQoKX0sZS5wcm90b3R5cGUuaWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faWR9LGUucHJvdG90eXBlLmV4cHJlc3Npb249ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZXhwcmVzc2lvbn0sZS5wcm90b3R5cGUub3A9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fb3BlcmF0b3J9LGUucHJvdG90eXBlLnN0cmVuZ3RoPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3N0cmVuZ3RofSxlfSgpKTt0LkNvbnN0cmFpbnQ9ZTt2YXIgcj0wfShyfHwocj17fSkpO3ZhciByOyFmdW5jdGlvbihlKXtmdW5jdGlvbiByKGUpe3JldHVybiBuZXcgdC5Bc3NvY2lhdGl2ZUFycmF5KGUpfWUuY3JlYXRlTWFwPXJ9KHJ8fChyPXt9KSk7dmFyIHI7IWZ1bmN0aW9uKHQpe3ZhciBlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0KXt2b2lkIDA9PT10JiYodD0iIiksdGhpcy5fdmFsdWU9MCx0aGlzLl9jb250ZXh0PW51bGwsdGhpcy5faWQ9cisrLHRoaXMuX25hbWU9dH1yZXR1cm4gZS5Db21wYXJlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuaWQoKS1lLmlkKCl9LGUucHJvdG90eXBlLmlkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lkfSxlLnByb3RvdHlwZS5uYW1lPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX25hbWV9LGUucHJvdG90eXBlLnNldE5hbWU9ZnVuY3Rpb24odCl7dGhpcy5fbmFtZT10fSxlLnByb3RvdHlwZS5jb250ZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2NvbnRleHR9LGUucHJvdG90eXBlLnNldENvbnRleHQ9ZnVuY3Rpb24odCl7dGhpcy5fY29udGV4dD10fSxlLnByb3RvdHlwZS52YWx1ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl92YWx1ZX0sZS5wcm90b3R5cGUuc2V0VmFsdWU9ZnVuY3Rpb24odCl7dGhpcy5fdmFsdWU9dH0sZS5wcm90b3R5cGUucGx1cz1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IHQuRXhwcmVzc2lvbih0aGlzLGUpfSxlLnByb3RvdHlwZS5taW51cz1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IHQuRXhwcmVzc2lvbih0aGlzLCJudW1iZXIiPT10eXBlb2YgZT8tZTpbLTEsZV0pfSxlLnByb3RvdHlwZS5tdWx0aXBseT1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IHQuRXhwcmVzc2lvbihbZSx0aGlzXSl9LGUucHJvdG90eXBlLmRpdmlkZT1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IHQuRXhwcmVzc2lvbihbMS9lLHRoaXNdKX0sZS5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJue25hbWU6dGhpcy5fbmFtZSx2YWx1ZTp0aGlzLl92YWx1ZX19LGV9KCk7dC5WYXJpYWJsZT1lO3ZhciByPTB9KHJ8fChyPXt9KSk7dmFyIHI7IWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSl7Zm9yKHZhciBpPTAsbj1mdW5jdGlvbigpe3JldHVybiAwfSxhPXQuY3JlYXRlTWFwKHQuVmFyaWFibGUuQ29tcGFyZSkscz0wLG89ZS5sZW5ndGg7bz5zOysrcyl7dmFyIHU9ZVtzXTtpZigibnVtYmVyIj09dHlwZW9mIHUpaSs9dTtlbHNlIGlmKHUgaW5zdGFuY2VvZiB0LlZhcmlhYmxlKWEuc2V0RGVmYXVsdCh1LG4pLnNlY29uZCs9MTtlbHNlIGlmKHUgaW5zdGFuY2VvZiByKXtpKz11LmNvbnN0YW50KCk7Zm9yKHZhciBjPXUudGVybXMoKSxmPTAsaD1jLnNpemUoKTtoPmY7ZisrKXt2YXIgbD1jLml0ZW1BdChmKTthLnNldERlZmF1bHQobC5maXJzdCxuKS5zZWNvbmQrPWwuc2Vjb25kfX1lbHNle2lmKCEodSBpbnN0YW5jZW9mIEFycmF5KSl0aHJvdyBuZXcgRXJyb3IoImludmFsaWQgRXhwcmVzc2lvbiBhcmd1bWVudDogIit1KTtpZigyIT09dS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKCJhcnJheSBtdXN0IGhhdmUgbGVuZ3RoIDIiKTt2YXIgcD11WzBdLGQ9dVsxXTtpZigibnVtYmVyIiE9dHlwZW9mIHApdGhyb3cgbmV3IEVycm9yKCJhcnJheSBpdGVtIDAgbXVzdCBiZSBhIG51bWJlciIpO2lmKGQgaW5zdGFuY2VvZiB0LlZhcmlhYmxlKWEuc2V0RGVmYXVsdChkLG4pLnNlY29uZCs9cDtlbHNle2lmKCEoZCBpbnN0YW5jZW9mIHIpKXRocm93IG5ldyBFcnJvcigiYXJyYXkgaXRlbSAxIG11c3QgYmUgYSB2YXJpYWJsZSBvciBleHByZXNzaW9uIik7aSs9ZC5jb25zdGFudCgpKnA7Zm9yKHZhciBjPWQudGVybXMoKSxmPTAsaD1jLnNpemUoKTtoPmY7ZisrKXt2YXIgbD1jLml0ZW1BdChmKTthLnNldERlZmF1bHQobC5maXJzdCxuKS5zZWNvbmQrPWwuc2Vjb25kKnB9fX19cmV0dXJue3Rlcm1zOmEsY29uc3RhbnQ6aX19dmFyIHI9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7dmFyIHQ9ZShhcmd1bWVudHMpO3RoaXMuX3Rlcm1zPXQudGVybXMsdGhpcy5fY29uc3RhbnQ9dC5jb25zdGFudH1yZXR1cm4gdC5wcm90b3R5cGUudGVybXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fdGVybXN9LHQucHJvdG90eXBlLmNvbnN0YW50PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2NvbnN0YW50fSx0LnByb3RvdHlwZS52YWx1ZT1mdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLl9jb25zdGFudCxlPTAscj10aGlzLl90ZXJtcy5zaXplKCk7cj5lO2UrKyl7dmFyIGk9dGhpcy5fdGVybXMuaXRlbUF0KGUpO3QrPWkuZmlyc3QudmFsdWUoKSppLnNlY29uZH1yZXR1cm4gdH0sdC5wcm90b3R5cGUucGx1cz1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IHQodGhpcyxlKX0sdC5wcm90b3R5cGUubWludXM9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyB0KHRoaXMsIm51bWJlciI9PXR5cGVvZiBlPy1lOlstMSxlXSl9LHQucHJvdG90eXBlLm11bHRpcGx5PWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgdChbZSx0aGlzXSl9LHQucHJvdG90eXBlLmRpdmlkZT1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IHQoWzEvZSx0aGlzXSl9LHR9KCk7dC5FeHByZXNzaW9uPXJ9KHJ8fChyPXt9KSk7dmFyIHI7IWZ1bmN0aW9uKHQpe3ZhciBlOyFmdW5jdGlvbih0KXtmdW5jdGlvbiBlKHQsZSxyLGkpe3ZvaWQgMD09PWkmJihpPTEpO3ZhciBuPTA7cmV0dXJuIG4rPTFlNipNYXRoLm1heCgwLE1hdGgubWluKDFlMyx0KmkpKSxuKz0xZTMqTWF0aC5tYXgoMCxNYXRoLm1pbigxZTMsZSppKSksbis9TWF0aC5tYXgoMCxNYXRoLm1pbigxZTMscippKSl9ZnVuY3Rpb24gcihlKXtyZXR1cm4gTWF0aC5tYXgoMCxNYXRoLm1pbih0LnJlcXVpcmVkLGUpKX10LmNyZWF0ZT1lLHQucmVxdWlyZWQ9ZSgxZTMsMWUzLDFlMyksdC5zdHJvbmc9ZSgxLDAsMCksdC5tZWRpdW09ZSgwLDEsMCksdC53ZWFrPWUoMCwwLDEpLHQuY2xpcD1yfShlPXQuU3RyZW5ndGh8fCh0LlN0cmVuZ3RoPXt9KSl9KHJ8fChyPXt9KSk7dmFyIHI7cmV0dXJuIGZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUodCl7dmFyIGU9MWUtODtyZXR1cm4gMD50P2U+LXQ6ZT50fWZ1bmN0aW9uIHIoKXtyZXR1cm4gdC5jcmVhdGVNYXAodC5Db25zdHJhaW50LkNvbXBhcmUpfWZ1bmN0aW9uIGkoKXtyZXR1cm4gdC5jcmVhdGVNYXAodS5Db21wYXJlKX1mdW5jdGlvbiBuKCl7cmV0dXJuIHQuY3JlYXRlTWFwKHQuVmFyaWFibGUuQ29tcGFyZSl9ZnVuY3Rpb24gYSgpe3JldHVybiB0LmNyZWF0ZU1hcCh0LlZhcmlhYmxlLkNvbXBhcmUpfXZhciBzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gcygpe3RoaXMuX2NuTWFwPXIoKSx0aGlzLl9yb3dNYXA9aSgpLHRoaXMuX3Zhck1hcD1uKCksdGhpcy5fZWRpdE1hcD1hKCksdGhpcy5faW5mZWFzaWJsZVJvd3M9W10sdGhpcy5fb2JqZWN0aXZlPW5ldyBmLHRoaXMuX2FydGlmaWNpYWw9bnVsbCx0aGlzLl9pZFRpY2s9MH1yZXR1cm4gcy5wcm90b3R5cGUuY3JlYXRlQ29uc3RyYWludD1mdW5jdGlvbihlLHIsaSxuKXt2b2lkIDA9PT1uJiYobj10LlN0cmVuZ3RoLnJlcXVpcmVkKTt2YXIgYT1uZXcgdC5Db25zdHJhaW50KGUscixpLG4pO3JldHVybiB0aGlzLmFkZENvbnN0cmFpbnQoYSksYX0scy5wcm90b3R5cGUuYWRkQ29uc3RyYWludD1mdW5jdGlvbih0KXt2YXIgcj10aGlzLl9jbk1hcC5maW5kKHQpO2lmKHZvaWQgMCE9PXIpdGhyb3cgbmV3IEVycm9yKCJkdXBsaWNhdGUgY29uc3RyYWludCIpO3ZhciBpPXRoaXMuX2NyZWF0ZVJvdyh0KSxuPWkucm93LGE9aS50YWcscz10aGlzLl9jaG9vc2VTdWJqZWN0KG4sYSk7aWYoMD09PXMudHlwZSgpJiZuLmFsbER1bW1pZXMoKSl7aWYoIWUobi5jb25zdGFudCgpKSl0aHJvdyBuZXcgRXJyb3IoInVuc2F0aXNmaWFibGUgY29uc3RyYWludCIpO3M9YS5tYXJrZXJ9aWYoMD09PXMudHlwZSgpKXtpZighdGhpcy5fYWRkV2l0aEFydGlmaWNpYWxWYXJpYWJsZShuKSl0aHJvdyBuZXcgRXJyb3IoInVuc2F0aXNmaWFibGUgY29uc3RyYWludCIpfWVsc2Ugbi5zb2x2ZUZvcihzKSx0aGlzLl9zdWJzdGl0dXRlKHMsbiksdGhpcy5fcm93TWFwLmluc2VydChzLG4pO3RoaXMuX2NuTWFwLmluc2VydCh0LGEpLHRoaXMuX29wdGltaXplKHRoaXMuX29iamVjdGl2ZSl9LHMucHJvdG90eXBlLnJlbW92ZUNvbnN0cmFpbnQ9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5fY25NYXAuZXJhc2UodCk7aWYodm9pZCAwPT09ZSl0aHJvdyBuZXcgRXJyb3IoInVua25vd24gY29uc3RyYWludCIpO3RoaXMuX3JlbW92ZUNvbnN0cmFpbnRFZmZlY3RzKHQsZS5zZWNvbmQpO3ZhciByPWUuc2Vjb25kLm1hcmtlcixpPXRoaXMuX3Jvd01hcC5lcmFzZShyKTtpZih2b2lkIDA9PT1pKXt2YXIgbj10aGlzLl9nZXRNYXJrZXJMZWF2aW5nU3ltYm9sKHIpO2lmKDA9PT1uLnR5cGUoKSl0aHJvdyBuZXcgRXJyb3IoImZhaWxlZCB0byBmaW5kIGxlYXZpbmcgcm93Iik7aT10aGlzLl9yb3dNYXAuZXJhc2UobiksaS5zZWNvbmQuc29sdmVGb3JFeChuLHIpLHRoaXMuX3N1YnN0aXR1dGUocixpLnNlY29uZCl9dGhpcy5fb3B0aW1pemUodGhpcy5fb2JqZWN0aXZlKX0scy5wcm90b3R5cGUuaGFzQ29uc3RyYWludD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fY25NYXAuY29udGFpbnModCl9LHMucHJvdG90eXBlLmFkZEVkaXRWYXJpYWJsZT1mdW5jdGlvbihlLHIpe3ZhciBpPXRoaXMuX2VkaXRNYXAuZmluZChlKTtpZih2b2lkIDAhPT1pKXRocm93IG5ldyBFcnJvcigiZHVwbGljYXRlIGVkaXQgdmFyaWFibGUiKTtpZihyPXQuU3RyZW5ndGguY2xpcChyKSxyPT09dC5TdHJlbmd0aC5yZXF1aXJlZCl0aHJvdyBuZXcgRXJyb3IoImJhZCByZXF1aXJlZCBzdHJlbmd0aCIpO3ZhciBuPW5ldyB0LkV4cHJlc3Npb24oZSksYT1uZXcgdC5Db25zdHJhaW50KG4sMix2b2lkIDAscik7dGhpcy5hZGRDb25zdHJhaW50KGEpO3ZhciBzPXRoaXMuX2NuTWFwLmZpbmQoYSkuc2Vjb25kLG89e3RhZzpzLGNvbnN0cmFpbnQ6YSxjb25zdGFudDowfTt0aGlzLl9lZGl0TWFwLmluc2VydChlLG8pfSxzLnByb3RvdHlwZS5yZW1vdmVFZGl0VmFyaWFibGU9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5fZWRpdE1hcC5lcmFzZSh0KTtpZih2b2lkIDA9PT1lKXRocm93IG5ldyBFcnJvcigidW5rbm93biBlZGl0IHZhcmlhYmxlIik7dGhpcy5yZW1vdmVDb25zdHJhaW50KGUuc2Vjb25kLmNvbnN0cmFpbnQpfSxzLnByb3RvdHlwZS5oYXNFZGl0VmFyaWFibGU9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX2VkaXRNYXAuY29udGFpbnModCl9LHMucHJvdG90eXBlLnN1Z2dlc3RWYWx1ZT1mdW5jdGlvbih0LGUpe3ZhciByPXRoaXMuX2VkaXRNYXAuZmluZCh0KTtpZih2b2lkIDA9PT1yKXRocm93IG5ldyBFcnJvcigidW5rbm93biBlZGl0IHZhcmlhYmxlIik7dmFyIGk9dGhpcy5fcm93TWFwLG49ci5zZWNvbmQsYT1lLW4uY29uc3RhbnQ7bi5jb25zdGFudD1lO3ZhciBzPW4udGFnLm1hcmtlcixvPWkuZmluZChzKTtpZih2b2lkIDAhPT1vKXJldHVybiBvLnNlY29uZC5hZGQoLWEpPDAmJnRoaXMuX2luZmVhc2libGVSb3dzLnB1c2gocyksdm9pZCB0aGlzLl9kdWFsT3B0aW1pemUoKTt2YXIgdT1uLnRhZy5vdGhlcixvPWkuZmluZCh1KTtpZih2b2lkIDAhPT1vKXJldHVybiBvLnNlY29uZC5hZGQoYSk8MCYmdGhpcy5faW5mZWFzaWJsZVJvd3MucHVzaCh1KSx2b2lkIHRoaXMuX2R1YWxPcHRpbWl6ZSgpO2Zvcih2YXIgYz0wLGY9aS5zaXplKCk7Zj5jOysrYyl7dmFyIG89aS5pdGVtQXQoYyksaD1vLnNlY29uZCxsPWguY29lZmZpY2llbnRGb3Iocyk7MCE9PWwmJmguYWRkKGEqbCk8MCYmMSE9PW8uZmlyc3QudHlwZSgpJiZ0aGlzLl9pbmZlYXNpYmxlUm93cy5wdXNoKG8uZmlyc3QpfXRoaXMuX2R1YWxPcHRpbWl6ZSgpfSxzLnByb3RvdHlwZS51cGRhdGVWYXJpYWJsZXM9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5fdmFyTWFwLGU9dGhpcy5fcm93TWFwLHI9MCxpPXQuc2l6ZSgpO2k+cjsrK3Ipe3ZhciBuPXQuaXRlbUF0KHIpLGE9ZS5maW5kKG4uc2Vjb25kKTt2b2lkIDAhPT1hP24uZmlyc3Quc2V0VmFsdWUoYS5zZWNvbmQuY29uc3RhbnQoKSk6bi5maXJzdC5zZXRWYWx1ZSgwKX19LHMucHJvdG90eXBlLl9nZXRWYXJTeW1ib2w9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxyPWZ1bmN0aW9uKCl7cmV0dXJuIGUuX21ha2VTeW1ib2woMSl9O3JldHVybiB0aGlzLl92YXJNYXAuc2V0RGVmYXVsdCh0LHIpLnNlY29uZH0scy5wcm90b3R5cGUuX2NyZWF0ZVJvdz1mdW5jdGlvbihyKXtmb3IodmFyIGk9ci5leHByZXNzaW9uKCksbj1uZXcgZihpLmNvbnN0YW50KCkpLGE9aS50ZXJtcygpLHM9MCxvPWEuc2l6ZSgpO28+czsrK3Mpe3ZhciB1PWEuaXRlbUF0KHMpO2lmKCFlKHUuc2Vjb25kKSl7dmFyIGg9dGhpcy5fZ2V0VmFyU3ltYm9sKHUuZmlyc3QpLGw9dGhpcy5fcm93TWFwLmZpbmQoaCk7dm9pZCAwIT09bD9uLmluc2VydFJvdyhsLnNlY29uZCx1LnNlY29uZCk6bi5pbnNlcnRTeW1ib2woaCx1LnNlY29uZCl9fXZhciBwPXRoaXMuX29iamVjdGl2ZSxkPXIuc3RyZW5ndGgoKSxfPXttYXJrZXI6YyxvdGhlcjpjfTtzd2l0Y2goci5vcCgpKXtjYXNlIDA6Y2FzZSAxOnZhciB2PTA9PT1yLm9wKCk/MTotMSx5PXRoaXMuX21ha2VTeW1ib2woMik7aWYoXy5tYXJrZXI9eSxuLmluc2VydFN5bWJvbCh5LHYpLGQ8dC5TdHJlbmd0aC5yZXF1aXJlZCl7dmFyIG09dGhpcy5fbWFrZVN5bWJvbCgzKTtfLm90aGVyPW0sbi5pbnNlcnRTeW1ib2wobSwtdikscC5pbnNlcnRTeW1ib2wobSxkKX1icmVhaztjYXNlIDI6aWYoZDx0LlN0cmVuZ3RoLnJlcXVpcmVkKXt2YXIgdz10aGlzLl9tYWtlU3ltYm9sKDMpLGc9dGhpcy5fbWFrZVN5bWJvbCgzKTtfLm1hcmtlcj13LF8ub3RoZXI9ZyxuLmluc2VydFN5bWJvbCh3LC0xKSxuLmluc2VydFN5bWJvbChnLDEpLHAuaW5zZXJ0U3ltYm9sKHcsZCkscC5pbnNlcnRTeW1ib2woZyxkKX1lbHNle3ZhciBiPXRoaXMuX21ha2VTeW1ib2woNCk7Xy5tYXJrZXI9YixuLmluc2VydFN5bWJvbChiKX19cmV0dXJuIG4uY29uc3RhbnQoKTwwJiZuLnJldmVyc2VTaWduKCkse3JvdzpuLHRhZzpffX0scy5wcm90b3R5cGUuX2Nob29zZVN1YmplY3Q9ZnVuY3Rpb24odCxlKXtmb3IodmFyIHI9dC5jZWxscygpLGk9MCxuPXIuc2l6ZSgpO24+aTsrK2kpe3ZhciBhPXIuaXRlbUF0KGkpO2lmKDE9PT1hLmZpcnN0LnR5cGUoKSlyZXR1cm4gYS5maXJzdH12YXIgcz1lLm1hcmtlci50eXBlKCk7cmV0dXJuKDI9PT1zfHwzPT09cykmJnQuY29lZmZpY2llbnRGb3IoZS5tYXJrZXIpPDA/ZS5tYXJrZXI6KHM9ZS5vdGhlci50eXBlKCksKDI9PT1zfHwzPT09cykmJnQuY29lZmZpY2llbnRGb3IoZS5vdGhlcik8MD9lLm90aGVyOmMpfSxzLnByb3RvdHlwZS5fYWRkV2l0aEFydGlmaWNpYWxWYXJpYWJsZT1mdW5jdGlvbih0KXt2YXIgcj10aGlzLl9tYWtlU3ltYm9sKDIpO3RoaXMuX3Jvd01hcC5pbnNlcnQocix0LmNvcHkoKSksdGhpcy5fYXJ0aWZpY2lhbD10LmNvcHkoKSx0aGlzLl9vcHRpbWl6ZSh0aGlzLl9hcnRpZmljaWFsKTt2YXIgaT1lKHRoaXMuX2FydGlmaWNpYWwuY29uc3RhbnQoKSk7dGhpcy5fYXJ0aWZpY2lhbD1udWxsO3ZhciBuPXRoaXMuX3Jvd01hcC5lcmFzZShyKTtpZih2b2lkIDAhPT1uKXt2YXIgYT1uLnNlY29uZDtpZihhLmlzQ29uc3RhbnQoKSlyZXR1cm4gaTt2YXIgcz10aGlzLl9hbnlQaXZvdGFibGVTeW1ib2woYSk7aWYoMD09PXMudHlwZSgpKXJldHVybiExO2Euc29sdmVGb3JFeChyLHMpLHRoaXMuX3N1YnN0aXR1dGUocyxhKSx0aGlzLl9yb3dNYXAuaW5zZXJ0KHMsYSl9Zm9yKHZhciBvPXRoaXMuX3Jvd01hcCx1PTAsYz1vLnNpemUoKTtjPnU7Kyt1KW8uaXRlbUF0KHUpLnNlY29uZC5yZW1vdmVTeW1ib2wocik7cmV0dXJuIHRoaXMuX29iamVjdGl2ZS5yZW1vdmVTeW1ib2wociksaX0scy5wcm90b3R5cGUuX3N1YnN0aXR1dGU9ZnVuY3Rpb24odCxlKXtmb3IodmFyIHI9dGhpcy5fcm93TWFwLGk9MCxuPXIuc2l6ZSgpO24+aTsrK2kpe3ZhciBhPXIuaXRlbUF0KGkpO2Euc2Vjb25kLnN1YnN0aXR1dGUodCxlKSxhLnNlY29uZC5jb25zdGFudCgpPDAmJjEhPT1hLmZpcnN0LnR5cGUoKSYmdGhpcy5faW5mZWFzaWJsZVJvd3MucHVzaChhLmZpcnN0KX10aGlzLl9vYmplY3RpdmUuc3Vic3RpdHV0ZSh0LGUpLHRoaXMuX2FydGlmaWNpYWwmJnRoaXMuX2FydGlmaWNpYWwuc3Vic3RpdHV0ZSh0LGUpfSxzLnByb3RvdHlwZS5fb3B0aW1pemU9ZnVuY3Rpb24odCl7Zm9yKDs7KXt2YXIgZT10aGlzLl9nZXRFbnRlcmluZ1N5bWJvbCh0KTtpZigwPT09ZS50eXBlKCkpcmV0dXJuO3ZhciByPXRoaXMuX2dldExlYXZpbmdTeW1ib2woZSk7aWYoMD09PXIudHlwZSgpKXRocm93IG5ldyBFcnJvcigidGhlIG9iamVjdGl2ZSBpcyB1bmJvdW5kZWQiKTt2YXIgaT10aGlzLl9yb3dNYXAuZXJhc2Uocikuc2Vjb25kO2kuc29sdmVGb3JFeChyLGUpLHRoaXMuX3N1YnN0aXR1dGUoZSxpKSx0aGlzLl9yb3dNYXAuaW5zZXJ0KGUsaSl9fSxzLnByb3RvdHlwZS5fZHVhbE9wdGltaXplPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuX3Jvd01hcCxlPXRoaXMuX2luZmVhc2libGVSb3dzOzAhPT1lLmxlbmd0aDspe3ZhciByPWUucG9wKCksaT10LmZpbmQocik7aWYodm9pZCAwIT09aSYmaS5zZWNvbmQuY29uc3RhbnQoKTwwKXt2YXIgbj10aGlzLl9nZXREdWFsRW50ZXJpbmdTeW1ib2woaS5zZWNvbmQpO2lmKDA9PT1uLnR5cGUoKSl0aHJvdyBuZXcgRXJyb3IoImR1YWwgb3B0aW1pemUgZmFpbGVkIik7dmFyIGE9aS5zZWNvbmQ7dC5lcmFzZShyKSxhLnNvbHZlRm9yRXgocixuKSx0aGlzLl9zdWJzdGl0dXRlKG4sYSksdC5pbnNlcnQobixhKX19fSxzLnByb3RvdHlwZS5fZ2V0RW50ZXJpbmdTeW1ib2w9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuY2VsbHMoKSxyPTAsaT1lLnNpemUoKTtpPnI7KytyKXt2YXIgbj1lLml0ZW1BdChyKSxhPW4uZmlyc3Q7aWYobi5zZWNvbmQ8MCYmNCE9PWEudHlwZSgpKXJldHVybiBhfXJldHVybiBjfSxzLnByb3RvdHlwZS5fZ2V0RHVhbEVudGVyaW5nU3ltYm9sPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1OdW1iZXIuTUFYX1ZBTFVFLHI9YyxpPXQuY2VsbHMoKSxuPTAsYT1pLnNpemUoKTthPm47KytuKXt2YXIgcz1pLml0ZW1BdChuKSxvPXMuZmlyc3QsdT1zLnNlY29uZDtpZih1PjAmJjQhPT1vLnR5cGUoKSl7dmFyIGY9dGhpcy5fb2JqZWN0aXZlLmNvZWZmaWNpZW50Rm9yKG8pLGg9Zi91O2U+aCYmKGU9aCxyPW8pfX1yZXR1cm4gcn0scy5wcm90b3R5cGUuX2dldExlYXZpbmdTeW1ib2w9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPU51bWJlci5NQVhfVkFMVUUscj1jLGk9dGhpcy5fcm93TWFwLG49MCxhPWkuc2l6ZSgpO2E+bjsrK24pe3ZhciBzPWkuaXRlbUF0KG4pLG89cy5maXJzdDtpZigxIT09by50eXBlKCkpe3ZhciB1PXMuc2Vjb25kLGY9dS5jb2VmZmljaWVudEZvcih0KTtpZigwPmYpe3ZhciBoPS11LmNvbnN0YW50KCkvZjtlPmgmJihlPWgscj1vKX19fXJldHVybiByfSxzLnByb3RvdHlwZS5fZ2V0TWFya2VyTGVhdmluZ1N5bWJvbD1mdW5jdGlvbih0KXtmb3IodmFyIGU9TnVtYmVyLk1BWF9WQUxVRSxyPWUsaT1lLG49YyxhPW4scz1uLG89bix1PXRoaXMuX3Jvd01hcCxmPTAsaD11LnNpemUoKTtoPmY7KytmKXt2YXIgbD11Lml0ZW1BdChmKSxwPWwuc2Vjb25kLGQ9cC5jb2VmZmljaWVudEZvcih0KTtpZigwIT09ZCl7dmFyIF89bC5maXJzdDtpZigxPT09Xy50eXBlKCkpbz1fO2Vsc2UgaWYoMD5kKXt2YXIgdj0tcC5jb25zdGFudCgpL2Q7cj52JiYocj12LGE9Xyl9ZWxzZXt2YXIgdj1wLmNvbnN0YW50KCkvZDtpPnYmJihpPXYscz1fKX19fXJldHVybiBhIT09bj9hOnMhPT1uP3M6b30scy5wcm90b3R5cGUuX3JlbW92ZUNvbnN0cmFpbnRFZmZlY3RzPWZ1bmN0aW9uKHQsZSl7Mz09PWUubWFya2VyLnR5cGUoKSYmdGhpcy5fcmVtb3ZlTWFya2VyRWZmZWN0cyhlLm1hcmtlcix0LnN0cmVuZ3RoKCkpLDM9PT1lLm90aGVyLnR5cGUoKSYmdGhpcy5fcmVtb3ZlTWFya2VyRWZmZWN0cyhlLm90aGVyLHQuc3RyZW5ndGgoKSl9LHMucHJvdG90eXBlLl9yZW1vdmVNYXJrZXJFZmZlY3RzPWZ1bmN0aW9uKHQsZSl7dmFyIHI9dGhpcy5fcm93TWFwLmZpbmQodCk7dm9pZCAwIT09cj90aGlzLl9vYmplY3RpdmUuaW5zZXJ0Um93KHIuc2Vjb25kLC1lKTp0aGlzLl9vYmplY3RpdmUuaW5zZXJ0U3ltYm9sKHQsLWUpfSxzLnByb3RvdHlwZS5fYW55UGl2b3RhYmxlU3ltYm9sPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10LmNlbGxzKCkscj0wLGk9ZS5zaXplKCk7aT5yOysrcil7dmFyIG49ZS5pdGVtQXQociksYT1uLmZpcnN0LnR5cGUoKTtpZigyPT09YXx8Mz09PWEpcmV0dXJuIG4uZmlyc3R9cmV0dXJuIGN9LHMucHJvdG90eXBlLl9tYWtlU3ltYm9sPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgdSh0LHRoaXMuX2lkVGljaysrKX0sc30oKTt0LlNvbHZlcj1zO3ZhciBvOyFmdW5jdGlvbih0KXt0W3QuSW52YWxpZD0wXT0iSW52YWxpZCIsdFt0LkV4dGVybmFsPTFdPSJFeHRlcm5hbCIsdFt0LlNsYWNrPTJdPSJTbGFjayIsdFt0LkVycm9yPTNdPSJFcnJvciIsdFt0LkR1bW15PTRdPSJEdW1teSJ9KG98fChvPXt9KSk7dmFyIHU9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7dGhpcy5faWQ9ZSx0aGlzLl90eXBlPXR9cmV0dXJuIHQuQ29tcGFyZT1mdW5jdGlvbih0LGUpe3JldHVybiB0LmlkKCktZS5pZCgpfSx0LnByb3RvdHlwZS5pZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9pZH0sdC5wcm90b3R5cGUudHlwZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl90eXBlfSx0fSgpLGM9bmV3IHUoMCwtMSksZj1mdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSl7dm9pZCAwPT09ZSYmKGU9MCksdGhpcy5fY2VsbE1hcD10LmNyZWF0ZU1hcCh1LkNvbXBhcmUpLHRoaXMuX2NvbnN0YW50PWV9cmV0dXJuIHIucHJvdG90eXBlLmNlbGxzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2NlbGxNYXB9LHIucHJvdG90eXBlLmNvbnN0YW50PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2NvbnN0YW50fSxyLnByb3RvdHlwZS5pc0NvbnN0YW50PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2NlbGxNYXAuZW1wdHkoKX0sci5wcm90b3R5cGUuYWxsRHVtbWllcz1mdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLl9jZWxsTWFwLGU9MCxyPXQuc2l6ZSgpO3I+ZTsrK2Upe3ZhciBpPXQuaXRlbUF0KGUpO2lmKDQhPT1pLmZpcnN0LnR5cGUoKSlyZXR1cm4hMX1yZXR1cm4hMH0sci5wcm90b3R5cGUuY29weT1mdW5jdGlvbigpe3ZhciB0PW5ldyByKHRoaXMuX2NvbnN0YW50KTtyZXR1cm4gdC5fY2VsbE1hcD10aGlzLl9jZWxsTWFwLmNvcHkoKSx0fSxyLnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX2NvbnN0YW50Kz10fSxyLnByb3RvdHlwZS5pbnNlcnRTeW1ib2w9ZnVuY3Rpb24odCxyKXt2b2lkIDA9PT1yJiYocj0xKTt2YXIgaT10aGlzLl9jZWxsTWFwLnNldERlZmF1bHQodCxmdW5jdGlvbigpe3JldHVybiAwfSk7ZShpLnNlY29uZCs9cikmJnRoaXMuX2NlbGxNYXAuZXJhc2UodCl9LHIucHJvdG90eXBlLmluc2VydFJvdz1mdW5jdGlvbih0LGUpe3ZvaWQgMD09PWUmJihlPTEpLHRoaXMuX2NvbnN0YW50Kz10Ll9jb25zdGFudCplO2Zvcih2YXIgcj10Ll9jZWxsTWFwLGk9MCxuPXIuc2l6ZSgpO24+aTsrK2kpe3ZhciBhPXIuaXRlbUF0KGkpO3RoaXMuaW5zZXJ0U3ltYm9sKGEuZmlyc3QsYS5zZWNvbmQqZSl9fSxyLnByb3RvdHlwZS5yZW1vdmVTeW1ib2w9ZnVuY3Rpb24odCl7dGhpcy5fY2VsbE1hcC5lcmFzZSh0KX0sci5wcm90b3R5cGUucmV2ZXJzZVNpZ249ZnVuY3Rpb24oKXt0aGlzLl9jb25zdGFudD0tdGhpcy5fY29uc3RhbnQ7Zm9yKHZhciB0PXRoaXMuX2NlbGxNYXAsZT0wLHI9dC5zaXplKCk7cj5lOysrZSl7dmFyIGk9dC5pdGVtQXQoZSk7aS5zZWNvbmQ9LWkuc2Vjb25kfX0sci5wcm90b3R5cGUuc29sdmVGb3I9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5fY2VsbE1hcCxyPWUuZXJhc2UodCksaT0tMS9yLnNlY29uZDt0aGlzLl9jb25zdGFudCo9aTtmb3IodmFyIG49MCxhPWUuc2l6ZSgpO2E+bjsrK24pZS5pdGVtQXQobikuc2Vjb25kKj1pfSxyLnByb3RvdHlwZS5zb2x2ZUZvckV4PWZ1bmN0aW9uKHQsZSl7dGhpcy5pbnNlcnRTeW1ib2wodCwtMSksdGhpcy5zb2x2ZUZvcihlKX0sci5wcm90b3R5cGUuY29lZmZpY2llbnRGb3I9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5fY2VsbE1hcC5maW5kKHQpO3JldHVybiB2b2lkIDAhPT1lP2Uuc2Vjb25kOjB9LHIucHJvdG90eXBlLnN1YnN0aXR1dGU9ZnVuY3Rpb24odCxlKXt2YXIgcj10aGlzLl9jZWxsTWFwLmVyYXNlKHQpO3ZvaWQgMCE9PXImJnRoaXMuaW5zZXJ0Um93KGUsci5zZWNvbmQpfSxyfSgpfShyfHwocj17fSkpLHJ9KX0sZnVuY3Rpb24odCxlKXsidXNlIHN0cmljdCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3ZhciByPXtDT05TVDoiY29uc3QiLE5PVEFOQVRUUklCVVRFOiJjb25zdCIsVkFSSUFCTEU6InZhciIsTEVGVDoibGVmdCIsUklHSFQ6InJpZ2h0IixUT1A6InRvcCIsQk9UVE9NOiJib3R0b20iLFdJRFRIOiJ3aWR0aCIsSEVJR0hUOiJoZWlnaHQiLENFTlRFUlg6ImNlbnRlclgiLENFTlRFUlk6ImNlbnRlclkiLFpJTkRFWDoiekluZGV4In07ZVsiZGVmYXVsdCJdPXJ9LGZ1bmN0aW9uKHQsZSl7InVzZSBzdHJpY3QiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt2YXIgcj17TEVROiJsZXEiLEVRVToiZXF1IixHRVE6ImdlcSJ9O2VbImRlZmF1bHQiXT1yfSxmdW5jdGlvbih0LGUscil7InVzZSBzdHJpY3QiO2Z1bmN0aW9uIGkodCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OnsiZGVmYXVsdCI6dH19ZnVuY3Rpb24gbih0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbiIpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTt2YXIgYT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIHI9MDtyPGUubGVuZ3RoO3IrKyl7dmFyIGk9ZVtyXTtpLmVudW1lcmFibGU9aS5lbnVtZXJhYmxlfHwhMSxpLmNvbmZpZ3VyYWJsZT0hMCwidmFsdWUiaW4gaSYmKGkud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGkua2V5LGkpfX1yZXR1cm4gZnVuY3Rpb24oZSxyLGkpe3JldHVybiByJiZ0KGUucHJvdG90eXBlLHIpLGkmJnQoZSxpKSxlfX0oKSxzPXIoMiksbz1pKHMpLHU9cigzKSxjPWkodSksZj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSl7bih0aGlzLHQpLHRoaXMuX25hbWU9ZS5uYW1lLHRoaXMuX3R5cGU9ZS50eXBlLHRoaXMuX3NvbHZlcj1lLnNvbHZlcix0aGlzLl9hdHRyPXt9LGUubmFtZXx8KHRoaXMuX2F0dHJbY1siZGVmYXVsdCJdLkxFRlRdPW5ldyBvWyJkZWZhdWx0Il0uVmFyaWFibGUsdGhpcy5fc29sdmVyLmFkZENvbnN0cmFpbnQobmV3IG9bImRlZmF1bHQiXS5Db25zdHJhaW50KHRoaXMuX2F0dHJbY1siZGVmYXVsdCJdLkxFRlRdLG9bImRlZmF1bHQiXS5PcGVyYXRvci5FcSwwKSksdGhpcy5fYXR0cltjWyJkZWZhdWx0Il0uVE9QXT1uZXcgb1siZGVmYXVsdCJdLlZhcmlhYmxlLHRoaXMuX3NvbHZlci5hZGRDb25zdHJhaW50KG5ldyBvWyJkZWZhdWx0Il0uQ29uc3RyYWludCh0aGlzLl9hdHRyW2NbImRlZmF1bHQiXS5UT1BdLG9bImRlZmF1bHQiXS5PcGVyYXRvci5FcSwwKSksdGhpcy5fYXR0cltjWyJkZWZhdWx0Il0uWklOREVYXT1uZXcgb1siZGVmYXVsdCJdLlZhcmlhYmxlLHRoaXMuX3NvbHZlci5hZGRDb25zdHJhaW50KG5ldyBvWyJkZWZhdWx0Il0uQ29uc3RyYWludCh0aGlzLl9hdHRyW2NbImRlZmF1bHQiXS5aSU5ERVhdLG9bImRlZmF1bHQiXS5PcGVyYXRvci5FcSwwKSkpfXJldHVybiBhKHQsW3trZXk6InRvSlNPTiIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm57bmFtZTp0aGlzLm5hbWUsbGVmdDp0aGlzLmxlZnQsdG9wOnRoaXMudG9wLHdpZHRoOnRoaXMud2lkdGgsaGVpZ2h0OnRoaXMuaGVpZ2h0fX19LHtrZXk6InRvU3RyaW5nIix2YWx1ZTpmdW5jdGlvbigpe0pTT04uc3RyaW5naWZ5KHRoaXMudG9KU09OKCksdm9pZCAwLDIpfX0se2tleToiZ2V0VmFsdWUiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9hdHRyW3RdP3RoaXMuX2F0dHJbdF0udmFsdWUoKTp2b2lkIDB9fSx7a2V5OiJfZ2V0QXR0ciIsdmFsdWU6ZnVuY3Rpb24odCl7aWYodGhpcy5fYXR0clt0XSlyZXR1cm4gdGhpcy5fYXR0clt0XTtzd2l0Y2godGhpcy5fYXR0clt0XT1uZXcgb1siZGVmYXVsdCJdLlZhcmlhYmxlLHQpe2Nhc2UgY1siZGVmYXVsdCJdLlJJR0hUOnRoaXMuX2dldEF0dHIoY1siZGVmYXVsdCJdLkxFRlQpLHRoaXMuX2dldEF0dHIoY1siZGVmYXVsdCJdLldJRFRIKSx0aGlzLl9zb2x2ZXIuYWRkQ29uc3RyYWludChuZXcgb1siZGVmYXVsdCJdLkNvbnN0cmFpbnQodGhpcy5fYXR0clt0XSxvWyJkZWZhdWx0Il0uT3BlcmF0b3IuRXEsdGhpcy5fYXR0cltjWyJkZWZhdWx0Il0uTEVGVF0ucGx1cyh0aGlzLl9hdHRyW2NbImRlZmF1bHQiXS5XSURUSF0pKSk7YnJlYWs7Y2FzZSBjWyJkZWZhdWx0Il0uQk9UVE9NOnRoaXMuX2dldEF0dHIoY1siZGVmYXVsdCJdLlRPUCksdGhpcy5fZ2V0QXR0cihjWyJkZWZhdWx0Il0uSEVJR0hUKSx0aGlzLl9zb2x2ZXIuYWRkQ29uc3RyYWludChuZXcgb1siZGVmYXVsdCJdLkNvbnN0cmFpbnQodGhpcy5fYXR0clt0XSxvWyJkZWZhdWx0Il0uT3BlcmF0b3IuRXEsdGhpcy5fYXR0cltjWyJkZWZhdWx0Il0uVE9QXS5wbHVzKHRoaXMuX2F0dHJbY1siZGVmYXVsdCJdLkhFSUdIVF0pKSk7YnJlYWs7Y2FzZSBjWyJkZWZhdWx0Il0uQ0VOVEVSWDp0aGlzLl9nZXRBdHRyKGNbImRlZmF1bHQiXS5MRUZUKSx0aGlzLl9nZXRBdHRyKGNbImRlZmF1bHQiXS5XSURUSCksdGhpcy5fc29sdmVyLmFkZENvbnN0cmFpbnQobmV3IG9bImRlZmF1bHQiXS5Db25zdHJhaW50KHRoaXMuX2F0dHJbdF0sb1siZGVmYXVsdCJdLk9wZXJhdG9yLkVxLHRoaXMuX2F0dHJbY1siZGVmYXVsdCJdLkxFRlRdLnBsdXModGhpcy5fYXR0cltjWyJkZWZhdWx0Il0uV0lEVEhdLmRpdmlkZSgyKSkpKTticmVhaztjYXNlIGNbImRlZmF1bHQiXS5DRU5URVJZOnRoaXMuX2dldEF0dHIoY1siZGVmYXVsdCJdLlRPUCksdGhpcy5fZ2V0QXR0cihjWyJkZWZhdWx0Il0uSEVJR0hUKSx0aGlzLl9zb2x2ZXIuYWRkQ29uc3RyYWludChuZXcgb1siZGVmYXVsdCJdLkNvbnN0cmFpbnQodGhpcy5fYXR0clt0XSxvWyJkZWZhdWx0Il0uT3BlcmF0b3IuRXEsdGhpcy5fYXR0cltjWyJkZWZhdWx0Il0uVE9QXS5wbHVzKHRoaXMuX2F0dHJbY1siZGVmYXVsdCJdLkhFSUdIVF0uZGl2aWRlKDIpKSkpfXJldHVybiB0aGlzLl9zb2x2ZXIudXBkYXRlVmFyaWFibGVzKCksdGhpcy5fYXR0clt0XX19LHtrZXk6Il9nZXRBdHRyVmFsdWUiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9nZXRBdHRyKHQpLnZhbHVlKCl9fSx7a2V5OiJuYW1lIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbmFtZX19LHtrZXk6ImxlZnQiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9nZXRBdHRyVmFsdWUoY1siZGVmYXVsdCJdLkxFRlQpfX0se2tleToicmlnaHQiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9nZXRBdHRyVmFsdWUoY1siZGVmYXVsdCJdLlJJR0hUKX19LHtrZXk6IndpZHRoIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZ2V0QXR0clZhbHVlKGNbImRlZmF1bHQiXS5XSURUSCl9fSx7a2V5OiJoZWlnaHQiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9nZXRBdHRyVmFsdWUoY1siZGVmYXVsdCJdLkhFSUdIVCl9fSx7a2V5OiJpbnRyaW5zaWNXaWR0aCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2ludHJpbnNpY1dpZHRofSxzZXQ6ZnVuY3Rpb24odCl7aWYodm9pZCAwIT09dCYmdCE9PXRoaXMuX2ludHJpbnNpY1dpZHRoKXt2YXIgZT10aGlzLl9nZXRBdHRyKGNbImRlZmF1bHQiXS5XSURUSCk7dm9pZCAwPT09dGhpcy5faW50cmluc2ljV2lkdGgmJnRoaXMuX3NvbHZlci5hZGRFZGl0VmFyaWFibGUoZSxvWyJkZWZhdWx0Il0uU3RyZW5ndGguY3JlYXRlKHRoaXMuX25hbWU/OTk4Ojk5OSwxZTMsMWUzKSksdGhpcy5faW50cmluc2ljV2lkdGg9dCx0aGlzLl9zb2x2ZXIuc3VnZ2VzdFZhbHVlKGUsdCksdGhpcy5fc29sdmVyLnVwZGF0ZVZhcmlhYmxlcygpfX19LHtrZXk6ImludHJpbnNpY0hlaWdodCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2ludHJpbnNpY0hlaWdodH0sc2V0OmZ1bmN0aW9uKHQpe2lmKHZvaWQgMCE9PXQmJnQhPT10aGlzLl9pbnRyaW5zaWNIZWlnaHQpe3ZhciBlPXRoaXMuX2dldEF0dHIoY1siZGVmYXVsdCJdLkhFSUdIVCk7dm9pZCAwPT09dGhpcy5faW50cmluc2ljSGVpZ2h0JiZ0aGlzLl9zb2x2ZXIuYWRkRWRpdFZhcmlhYmxlKGUsb1siZGVmYXVsdCJdLlN0cmVuZ3RoLmNyZWF0ZSh0aGlzLl9uYW1lPzk5ODo5OTksMWUzLDFlMykpLHRoaXMuX2ludHJpbnNpY0hlaWdodD10LHRoaXMuX3NvbHZlci5zdWdnZXN0VmFsdWUoZSx0KSx0aGlzLl9zb2x2ZXIudXBkYXRlVmFyaWFibGVzKCl9fX0se2tleToidG9wIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZ2V0QXR0clZhbHVlKGNbImRlZmF1bHQiXS5UT1ApfX0se2tleToiYm90dG9tIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZ2V0QXR0clZhbHVlKGNbImRlZmF1bHQiXS5CT1RUT00pfX0se2tleToiY2VudGVyWCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2dldEF0dHJWYWx1ZShjWyJkZWZhdWx0Il0uQ0VOVEVSWCl9fSx7a2V5OiJjZW50ZXJZIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZ2V0QXR0clZhbHVlKGNbImRlZmF1bHQiXS5DRU5URVJZKX19LHtrZXk6InpJbmRleCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2dldEF0dHJWYWx1ZShjWyJkZWZhdWx0Il0uWklOREVYKX19LHtrZXk6InR5cGUiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl90eXBlfX1dKSx0fSgpO2VbImRlZmF1bHQiXT1mfV0pOwovLyMgc291cmNlTWFwcGluZ1VSTD0ud2VicGFjay5yZXMuMTQ1OTQ1MDUyOTAwM182Njc2NjkuanMubWFw")], { type: "text/javascript" })));
	};
	var DEFAULT_THREAD_COUNT = 4;
	
	var LayoutClient = function () {
	  function LayoutClient(threadCount) {
	    var workerFactory = arguments.length <= 1 || arguments[1] === undefined ? LayoutWorker : arguments[1];
	    var ProxyClass = arguments.length <= 2 || arguments[2] === undefined ? _workerProxy2.default : arguments[2];
	
	    _classCallCheck(this, LayoutClient);
	
	    this.views = {};
	    this.workers = [];
	    this.currentWorker = 0;
	
	    // Number of workers determined by either:
	    // - The constructor
	    // - The number of cores on the machine
	    // - A default fallback
	    var cores = navigator.hardwareConcurrency;
	    var workerCount = threadCount || cores || DEFAULT_THREAD_COUNT;
	
	    // Instantiate the workers and add listeners to each one
	    while (workerCount--) {
	      var proxy = new ProxyClass(workerFactory());
	      this.workers.push(proxy);
	    }
	  }
	
	  _createClass(LayoutClient, [{
	    key: "registerView",
	    value: function registerView( // eslint-disable-line max-params
	    viewName, size, spacing, callback) {
	      if (this.views[viewName]) {
	        return;
	      }
	
	      this.views[viewName] = {
	        workerId: this.currentWorker, callback: callback
	      };
	
	      this.workers[this.currentWorker].run("registerView", {
	        viewName: viewName, size: size, spacing: spacing
	      }, callback);
	
	      // Cycle through the worker pool
	      if (this.currentWorker === this.workers.length - 1) {
	        this.currentWorker = 0;
	      } else {
	        this.currentWorker++;
	      }
	    }
	  }, {
	    key: "deregisterView",
	    value: function deregisterView(viewName, callback) {
	      if (!this.views[viewName]) {
	        return;
	      }
	
	      var worker = this.workerForView(viewName);
	      if (worker) {
	        worker.run("deregisterView", { viewName: viewName }, callback);
	        this.views[viewName] = null;
	      }
	    }
	  }, {
	    key: "workerForView",
	    value: function workerForView(viewName) {
	      if (!this.views[viewName]) {
	        return null;
	      }
	      return this.workers[this.views[viewName].workerId];
	    }
	  }, {
	    key: "run",
	    value: function run(method, args, callback) {
	      var worker = this.workerForView(args.viewName);
	      if (worker) {
	        worker.run(method, args, callback);
	      }
	    }
	  }, {
	    key: "terminate",
	    value: function terminate() {
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;
	
	      try {
	        for (var _iterator = this.workers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var worker = _step.value;
	
	          worker.terminate();
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }
	
	      this.workers = [];
	      this.currentWorker = 0;
	    }
	  }]);
	
	  return LayoutClient;
	}();

	exports.default = LayoutClient;

/***/ },
/* 4 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var WorkerProxy = function () {
	  function WorkerProxy(worker) {
	    var _this = this;
	
	    _classCallCheck(this, WorkerProxy);
	
	    this.worker = worker;
	    this.callbacks = {};
	    this.worker.onmessage = function (_ref) {
	      var message = _ref.data;
	
	      var method = message.method || null;
	      if (method) {
	        var _cb = _this.callbacks[method];
	        if (_cb) {
	          _cb(message.result || null);
	          _this.callbacks[method] = null;
	        }
	      }
	    };
	  }
	
	  _createClass(WorkerProxy, [{
	    key: "run",
	    value: function run(method, args, cb) {
	      this.callbacks[method] = cb;
	      this.worker.postMessage({ method: method, args: args });
	    }
	  }, {
	    key: "terminate",
	    value: function terminate() {
	      this.worker.terminate();
	    }
	  }]);
	
	  return WorkerProxy;
	}();

	exports.default = WorkerProxy;

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _extractLayoutProps = __webpack_require__(6);
	
	var _extractLayoutProps2 = _interopRequireDefault(_extractLayoutProps);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var View = function (_Component) {
	  _inherits(View, _Component);
	
	  function View(props, context) {
	    _classCallCheck(this, View);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(View).call(this, props, context));
	
	    _this.state = {
	      subviews: null
	    };
	    return _this;
	  }
	
	  _createClass(View, [{
	    key: "componentDidMount",
	    value: function componentDidMount() {
	      var _this2 = this;
	
	      var _props = this.props;
	      var container = _props.container;
	      var children = _props.children;
	      var name = _props.name;
	      var width = _props.width;
	      var height = _props.height;
	      var spacing = _props.spacing;
	
	      var size = { width: width, height: height };
	      var client = this.context.client;
	
	
	      var element = (0, _react.createElement)(container, null, children);
	      var layoutProps = (0, _extractLayoutProps2.default)(element);
	
	      client.registerView(name, size, spacing, function () {
	        client.run("initializeSubviews", {
	          viewName: name, layoutProps: layoutProps
	        }, function (layout) {
	          return _this2.onLayout(layout);
	        });
	      });
	    }
	  }, {
	    key: "componentWillReceiveProps",
	    value: function componentWillReceiveProps(nextProps) {
	      var _this3 = this;
	
	      var viewName = nextProps.name;
	      var width = nextProps.width;
	      var height = nextProps.height;
	      var _props2 = this.props;
	      var oldWidth = _props2.width;
	      var oldHeight = _props2.height;
	
	      if (width === oldWidth && height === oldHeight) {
	        return;
	      }
	      this.context.client.run("setSize", {
	        viewName: viewName, size: { width: width, height: height }
	      }, function (layout) {
	        return _this3.onLayout(layout);
	      });
	    }
	  }, {
	    key: "onLayout",
	    value: function onLayout(subviews) {
	      this.setState({ subviews: subviews });
	    }
	  }, {
	    key: "getChildContext",
	    value: function getChildContext() {
	      return { subviews: this.state.subviews };
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      var _props3 = this.props;
	      var container = _props3.container;
	      var children = _props3.children;
	      var width = _props3.width;
	      var height = _props3.height;
	      var style = _props3.style;
	
	      var newProps = {
	        style: _extends({ width: width, height: height }, style)
	      };
	      return (0, _react.createElement)(container, newProps, children);
	    }
	  }]);
	
	  return View;
	}(_react.Component);
	
	View.childContextTypes = {
	  subviews: _react.PropTypes.object
	};
	View.contextTypes = {
	  client: _react.PropTypes.object
	};
	exports.default = View;

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _react = __webpack_require__(2);
	
	var extractLayoutProps = function extractLayoutProps(element) {
	  var acc = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
	
	  if (!element || !element.props) {
	    return null;
	  }
	
	  var _element$props = element.props;
	  var rawConstraints = _element$props.constraints;
	  var children = _element$props.children;
	  var intrinsicWidth = _element$props.intrinsicWidth;
	  var intrinsicHeight = _element$props.intrinsicHeight;
	  var name = _element$props.name;
	
	
	  if (children) {
	    _react.Children.forEach(children, function (child) {
	      return extractLayoutProps(child, acc);
	    });
	  }
	
	  var constraints = rawConstraints ? rawConstraints.map(function (c) {
	    return c.build();
	  }) : null;
	
	  acc.push({
	    constraints: constraints || null,
	    intrinsicWidth: intrinsicWidth || null,
	    intrinsicHeight: intrinsicHeight || null,
	    name: name || null
	  });
	
	  return acc;
	};
	
	exports.default = extractLayoutProps;

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var transformer = function transformer(ComposedComponent, props, layout, layoutTransformer) {
	  var layoutProps = layoutTransformer(layout);
	  var newProps = _extends({}, props, layoutProps.props, {
	    style: _extends({}, props.style, layoutProps.style)
	  });
	
	  return (0, _react.createElement)(ComposedComponent, newProps, props.children);
	};
	// The default DOM layout map.
	// Absolutely positions with style attributes.
	var defaultLayoutTransformer = function defaultLayoutTransformer(layout) {
	  return {
	    style: {
	      position: "absolute",
	      width: layout.width,
	      height: layout.height,
	      top: layout.top,
	      left: layout.left
	    }
	  };
	};
	
	exports.default = function (ComposedComponent) {
	  var _class, _temp;
	
	  var layoutTransformer = arguments.length <= 1 || arguments[1] === undefined ? // eslint-disable-line space-infix-ops
	  defaultLayoutTransformer : arguments[1];
	  return _temp = _class = function (_Component) {
	    _inherits(_class, _Component);
	
	    function _class() {
	      _classCallCheck(this, _class);
	
	      return _possibleConstructorReturn(this, Object.getPrototypeOf(_class).apply(this, arguments));
	    }
	
	    _createClass(_class, [{
	      key: "render",
	      value: function render() {
	        var zeroLayout = {
	          width: 0,
	          height: 0,
	          top: 0,
	          right: 0,
	          bottom: 0,
	          left: 0
	        };
	
	        var name = this.props.name;
	        var subviews = this.context.subviews;
	
	        var layout = subviews && name && subviews[name] && subviews[name].layout ? subviews[name].layout : zeroLayout;
	
	        // Is this an AutoDOM component?
	        if (typeof ComposedComponent === "string") {
	          return transformer(ComposedComponent, this.props, layout, layoutTransformer);
	        }
	
	        // If not, pass the layout props to the wrapped component
	        return _react2.default.createElement(ComposedComponent, _extends({}, this.props, {
	          layout: layout
	        }));
	      }
	    }]);
	
	    return _class;
	  }(_react.Component), _class.contextTypes = {
	    subviews: _react.PropTypes.object
	  }, _temp;
	};

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.whitelist = undefined;
	
	var _react = __webpack_require__(2);
	
	var _subview = __webpack_require__(7);
	
	var _subview2 = _interopRequireDefault(_subview);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// This is to override any DOM nodes that can't
	// use the default position: absolute transform
	/* eslint-disable new-cap */
	var transformers = {};
	
	var whitelist = exports.whitelist = [
	// block level elements (should all be safe)
	"address", "article", "aside", "blockquote", "canvas", "dd", "div", "dl", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "li", "main", "nav", "noscript", "ol", "output", "p", "pre", "section", "table", "ul", "video", "div", "img", "blockquote",
	
	// safe inline elements
	"img", "span", "button", "input", "label", "select", "textarea"];
	
	exports.default = Object.keys(_react.DOM).filter(function (key) {
	  return whitelist.indexOf(key) !== -1;
	}).reduce(function (acc, key) {
	  acc[key] = transformers[key] ? (0, _subview2.default)(key, transformers[key]) : (0, _subview2.default)(key);
	  return acc;
	}, {});

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _subview = __webpack_require__(7);
	
	var _subview2 = _interopRequireDefault(_subview);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/* eslint-disable new-cap */
	
	
	var transformers = {
	  rect: function rect(layout) {
	    return {
	      transformType: "props",
	      props: {
	        x: layout.left,
	        y: layout.top,
	        width: layout.width,
	        height: layout.height
	      }
	    };
	  },
	  line: function line(layout) {
	    return {
	      transformType: "props",
	      props: {
	        x1: layout.left,
	        x2: layout.right,
	        y1: layout.top,
	        y2: layout.bottom
	      }
	    };
	  },
	  text: function text(layout) {
	    return {
	      transformType: "props",
	      props: {
	        x: layout.left,
	        y: layout.top
	      }
	    };
	  },
	  circle: function circle(layout) {
	    return {
	      transformType: "props",
	      props: {
	        cx: layout.left + layout.width / 2,
	        cy: layout.top + layout.height / 2,
	        r: layout.width / 2
	      }
	    };
	  },
	  ellipse: function ellipse(layout) {
	    return {
	      transformType: "props",
	      props: {
	        cx: layout.left + layout.width / 2,
	        cy: layout.top + layout.height / 2,
	        rx: layout.width / 2,
	        ry: layout.height / 2
	      }
	    };
	  }
	};
	
	exports.default = Object.keys(transformers).reduce(function (acc, key) {
	  acc[key] = (0, _subview2.default)(key, transformers[key]);
	  return acc;
	}, {});

/***/ },
/* 10 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var ConstraintBuilder = function () {
	  function ConstraintBuilder(constraint) {
	    _classCallCheck(this, ConstraintBuilder);
	
	    this.constraint = constraint || null;
	  }
	
	  _createClass(ConstraintBuilder, [{
	    key: "whichSide",
	    value: function whichSide(prop) {
	      return this.constraint && prop + "1" in this.constraint ? 2 : 1;
	    }
	  }, {
	    key: "subview",
	    value: function subview(name) {
	      var side = this.whichSide("view");
	      return new ConstraintBuilder(_extends({}, this.constraint, _defineProperty({}, "view" + side, name)));
	    }
	  }, {
	    key: "constant",
	    value: function constant(_constant) {
	      return new ConstraintBuilder(_extends({}, this.constraint, {
	        attr2: "const",
	        constant: _constant
	      }));
	    }
	  }, {
	    key: "plus",
	    value: function plus(constant) {
	      return new ConstraintBuilder(_extends({}, this.constraint, {
	        constant: constant
	      }));
	    }
	  }, {
	    key: "minus",
	    value: function minus(constant) {
	      return new ConstraintBuilder(_extends({}, this.constraint, {
	        constant: -constant
	      }));
	    }
	  }, {
	    key: "times",
	    value: function times(multiplier) {
	      return new ConstraintBuilder(_extends({}, this.constraint, {
	        multiplier: multiplier
	      }));
	    }
	  }, {
	    key: "withPriority",
	    value: function withPriority(priority) {
	      return new ConstraintBuilder(_extends({}, this.constraint, {
	        priority: priority
	      }));
	    }
	  }, {
	    key: "build",
	    value: function build() {
	      return this.constraint;
	    }
	  }, {
	    key: "superview",
	    get: function get() {
	      var side = this.whichSide("view");
	      return new ConstraintBuilder(_extends({}, this.constraint, _defineProperty({}, "view" + side, null)));
	    }
	  }, {
	    key: "to",
	    get: function get() {
	      return new ConstraintBuilder(this.constraint);
	    }
	  }, {
	    key: "be",
	    get: function get() {
	      return new ConstraintBuilder(this.constraint);
	    }
	  }, {
	    key: "equal",
	    get: function get() {
	      return new ConstraintBuilder(_extends({}, this.constraint, {
	        relation: "equ"
	      }));
	    }
	  }, {
	    key: "lessThanOrEqualTo",
	    get: function get() {
	      return new ConstraintBuilder(_extends({}, this.constraint, {
	        relation: "leq"
	      }));
	    }
	  }, {
	    key: "greaterThanOrEqualTo",
	    get: function get() {
	      return new ConstraintBuilder(_extends({}, this.constraint, {
	        relation: "geq"
	      }));
	    }
	  }, {
	    key: "width",
	    get: function get() {
	      var side = this.whichSide("attr");
	      return new ConstraintBuilder(_extends({}, this.constraint, _defineProperty({}, "attr" + side, "width")));
	    }
	  }, {
	    key: "height",
	    get: function get() {
	      var side = this.whichSide("attr");
	      return new ConstraintBuilder(_extends({}, this.constraint, _defineProperty({}, "attr" + side, "height")));
	    }
	  }, {
	    key: "top",
	    get: function get() {
	      var side = this.whichSide("attr");
	      return new ConstraintBuilder(_extends({}, this.constraint, _defineProperty({}, "attr" + side, "top")));
	    }
	  }, {
	    key: "left",
	    get: function get() {
	      var side = this.whichSide("attr");
	      return new ConstraintBuilder(_extends({}, this.constraint, _defineProperty({}, "attr" + side, "left")));
	    }
	  }, {
	    key: "bottom",
	    get: function get() {
	      var side = this.whichSide("attr");
	      return new ConstraintBuilder(_extends({}, this.constraint, _defineProperty({}, "attr" + side, "bottom")));
	    }
	  }, {
	    key: "right",
	    get: function get() {
	      var side = this.whichSide("attr");
	      return new ConstraintBuilder(_extends({}, this.constraint, _defineProperty({}, "attr" + side, "right")));
	    }
	  }, {
	    key: "centerX",
	    get: function get() {
	      var side = this.whichSide("attr");
	      return new ConstraintBuilder(_extends({}, this.constraint, _defineProperty({}, "attr" + side, "centerX")));
	    }
	  }, {
	    key: "centerY",
	    get: function get() {
	      var side = this.whichSide("attr");
	      return new ConstraintBuilder(_extends({}, this.constraint, _defineProperty({}, "attr" + side, "centerY")));
	    }
	  }]);
	
	  return ConstraintBuilder;
	}(); // Not typechecking with flow (doesn't support getters yet)
	
	exports.default = function () {
	  return new ConstraintBuilder();
	};

/***/ }
/******/ ])
});
;
//# sourceMappingURL=radium-constraints.js.map